--- tinypy.c.org	2010-05-20 17:21:34.195371840 +0200
+++ tinypy.cpp	2010-07-06 20:49:12.780690579 +0200
@@ -119,6 +119,10 @@
 #ifndef tp_inline
 #error "Unsuported compiler"
 #endif
+// MEANX : Redirect printf
+bool pyPrintf(const char *fmt,...);
+#define printf pyPrintf
+// ************************
 
 /*  #define tp_malloc(x) calloc((x),1)
     #define tp_realloc(x,y) realloc(x,y)
@@ -462,7 +466,8 @@
 
 tp_inline static void tp_echo(TP,tp_obj e) {
     e = tp_str(tp,e);
-    fwrite(e.string.val,1,e.string.len,stdout);
+    //fwrite(e.string.val,1,e.string.len,stdout); // MEANX
+    printf("%s",e.string.val);
 }
 
 /* Function: tp_string_n
@@ -980,12 +985,14 @@
  * This is how you can create a tinypy function object which, when called in
  * the script, calls the provided C function.
  */
+
+//tp_obj tp_fnc_new(TP,int t, void *v, tp_obj c,tp_obj s, tp_obj g) ;
 tp_obj tp_fnc(TP,tp_obj v(TP)) {
-    return tp_fnc_new(tp,0,v,tp_None,tp_None,tp_None);
+    return tp_fnc_new(tp,0,(void *)v,tp_None,tp_None, tp_None);
 }
 
 tp_obj tp_method(TP,tp_obj self,tp_obj v(TP)) {
-    return tp_fnc_new(tp,2,v,tp_None,self,tp_None);
+    return tp_fnc_new(tp,2,(void*)v,tp_None,self,tp_None);
 }
 
 /* Function: tp_data
@@ -2198,6 +2205,7 @@
         exit(-1);
 #else
         tp->ex = e;
+        printf("\nException:\n"); tp_echo(tp,e); printf("\n");
         longjmp(tp->nextexpr,1);
 #endif
     }
@@ -2234,6 +2242,7 @@
     tp_print_stack(tp);
     exit(-1);
 #else
+    tp_print_stack(tp);
     longjmp(tp->nextexpr,1);
 #endif
 }
@@ -2425,6 +2434,7 @@
             #ifdef TP_SANDBOX
             tp_bounds(tp,cur,SVBC);
             #endif
+            {
             int a = (*(cur+1)).string.val-f->code.string.val;
             RA = tp_def(tp,
                 /*tp_string_n((*(cur+1)).string.val,(SVBC-1)*4),*/
@@ -2432,6 +2442,7 @@
                 f->globals);
             cur += SVBC; continue;
             }
+            }
             break;
 
         case TP_IRETURN: tp_return(tp,RA); SR(0); break;
@@ -2445,11 +2456,13 @@
             tp_bounds(tp,cur,VA);
             #endif
             ;
+            {
             int a = (*(cur+1)).string.val-f->code.string.val;
 /*            f->line = tp_string_n((*(cur+1)).string.val,VA*4-1);*/
             f->line = tp_string_sub(tp,f->code,a,a+VA*4-1);
 /*             fprintf(stderr,"%7d: %s\n",UVBC,f->line.string.val);*/
             cur += VA; f->lineno = UVBC;
+            }
             break;
         case TP_IFILE: f->fname = RA; break;
         case TP_INAME: f->name = RA; break;
@@ -2558,7 +2571,7 @@
 
 void tp_builtins(TP) {
     tp_obj o;
-    struct {const char *s;void *f;} b[] = {
+    struct {const char *s;tp_obj (*f)(TP);} b[] = {
     {"print",tp_print}, {"range",tp_range}, {"min",tp_min},
     {"max",tp_max}, {"bind",tp_bind}, {"copy",tp_copy},
     {"import",tp_import_}, {"len",tp_len_}, {"assert",tp_assert},
